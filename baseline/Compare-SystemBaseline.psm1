<#
.SYNOPSIS
Performs comparison of two system baselines files or objects.

.DESCRIPTION
The Compare-SystemBaseline.ps1 script gets the content of two comparison files 
generated by Create-SystemBaseline.ps1. It will recurse through each file seperately 
and produce an output file with only the difference, denoting the file the differing 
line was in. This shows the changes in each file so you can easily compare.

(I should create a specific file type to help
error detection if a file was not generated by the Create-SystemBaseline.ps1 script.)

.PARAMETER ReferrenceObject
Provide path of the referrence comparison object.

.PARAMETER DifferenceObject
Provide path of the difference comparison object.

.PARAMETER Destination
Provide the path of the comparison output file.

.INPUTS
None. You cannot pipe objects to Compare-SystemBaseline.ps1.

.OUTPUTS
File. Create-SystemBaseline does not return an object.
It will print to a file.

.EXAMPLE
PS> .\Compare-SystemBaseline.ps1

#>

Param (
        [Parameter(Mandatory=$true,ValueFromPipeline=$true)][String]$ReferrenceObject,
        [Parameter(Mandatory=$true,ValueFromPipeline=$true)][String]$DifferenceObject,
        [Parameter(Mandatory=$true,ValueFromPipeline=$true)][String]$Destination
)

<#
.SYNOPSIS
Compares two system baseline array objects.

.DESCRIPTION
The Compare-SObjects function evaluates each objects items against a set of conditions
and determines to compare the item in the second object. This is a one-way comparison only.

.PARAMETER Object1
An array of the contents of a Create-SystemBaseline script output for comparison. 

.PARAMETER Object2
An array of the contents of a Create-SystemBaseline script output to compare against.

.PARAMETER Destination
Provide the path of the comparison output file.

.INPUTS
None. You cannot pipe objects to Compare-SystemBaseline.ps1.

.OUTPUTS
String Array. Items in this Object1 that are not found in Object2 are returned.

.EXAMPLE
PS> Compare-SObjects -Object1 $file1 -Object2 $file2 -Indicator "<=" 

.EXAMPLE
PS> Compare-SObjects -Object1 $file1 -Object2 $file2 -Indicator "<=" | Out-File $outFile -Append

#>
Function $Script:Compare-SObjects()
{
    Param (
        [Parameter(Mandatory=$true,ValueFromPipeline=$true)][Array]$Object1,
        [Parameter(Mandatory=$true,ValueFromPipeline=$true)][Array]$Object2,
        [Parameter(Mandatory=$true,ValueFromPipeline=$true)][String]$Indicator
    )
    [String[]]$results = @()
    
    # i is used to track the line number.
    $i = 0

    # header is used to test of a table header is captured
    # and to only print that header once in each component.
    # Otherwise everytime a line is different it would print 
    # the table header.
    [Bool]$header = $false

    # Enumerate each line and check for header fields, and content.
    # When content is found, check object2 if it contains the content.
    # If not store in the output.
    ForEach($line in $object1)
    {
        # This writes the progress bar to the console while compare the file.
        # It divides the current iteration through lines by the total number of lines.
        Write-Progress -Activity "Writing items to $Destination" `
            -Status ((($i+1)/($object1.Count * 2) * 100).ToString("#") + "% Complete") `
            -PercentComplete (($i+1)/($object1.Count * 2) * 100) 
            
        # This switch statement matches the component headers and will
        # write those headers to the output file everytime.
        switch -Regex ($line)
        {
            '^Start' 
            {
                $results += "$line `r`n" 
            }
            '^End' 
            {
                $results += "$line `r`n`r`n"
            }
            
            <#
                This switch case matches the specific component object headers
                for each component as they can be dynamic. 
                It will ensure the column headings are always present IF there is a difference.
                Otherwise if that component section has no differences it will NOT
                write out these headers and the component section will be empty.
            
                Think of the table headers returned when running a single CMDLET.
                Not the larger component headers of the baseline.
            
                This will also create the SideIndicator column with the direction.
            
                It basically matches the minus symbol a bunch of times and only that
                optionally with spaces on the front of the line.
            #>
            '^\s*?-+?' 
            {
                
                # Becasuse this case matches the line with the dashes, the column names
                # are on the previous line (above) and therefor I must gather that line
                # in order to provide the actuall text names.
                [string]$tableColumnHeadings =  "SideIndicator`t" + $object1[$i-1] + "`r`n"
            
                # Purely the dashed line
                [string]$tableColumnHeadings += "-------------`t" + $line
            
                # Is set true when a new component table header is captured so that it is
                # only printed once later on if it needs to be printed.
                $header = $true
            }
            # Matched when component or table header lines aren't match. So the actual conent.
            default
            {
                # Check if the right file contains the current line 
                # (does not like whitespace differences)
                if($object2 -notcontains $line)
                {
                    
                    # If a header has been captured, write it out because we have a difference
                    # This procduces a nice table header for the differing objects.
                    # Sets header to false indicating it has been used and to collect a new one.
                    if($header)
                    {
                        # Write the table column headings
                        $results += $tableColumnHeadings #| Out-File $outFile -Append
                        $header = $false
                    }

                    # Always write the side indicator and the actuall differing line.
                    $results += $Indicator + "           `t" + $line #| Out-File $outFile -Append
                }
            }
        }
        $i++
    }
    $results
}

# Import each files contents
$file1 = Get-Content $ReferrenceObject
$file2 = Get-Content $DifferenceObject

# Calculate hash of each file
$file1Hash = Get-FileHash -Algorithm SHA256 -Path $ReferrenceObject | Format-List
$file2Hash = Get-FileHash -Algorithm SHA256 -Path $DifferenceObject | Format-List

# Delete the output file if it exists
if(Test-Path $Destination)
{
    Remove-item $Destination
} 

# Create the output file
New-Item $Destination -ItemType File | Out-Null

# Create file header information
"This compare was run on: " + (Get-Date) | Out-File $Destination
"Between files " | Out-File $Destination -Append
"Left(<=) $ReferrenceObject" | Out-File $Destination -Append
"Right(=>) $DifferenceObject `r`n" | Out-File $Destination -Append
$file1Hash | Out-File $Destination -Append
$file2Hash | Out-File $Destination -Append


Compare-SObjects -Object1 $file1 -Object2 $file2 -Indicator "<=" | Out-File $Destination -Append
Compare-SObjects -Object1 $file2 -Object2 $file1 -Indicator "=>" | Out-File $Destination -Append

Remove-Variable file1,file2,destination

